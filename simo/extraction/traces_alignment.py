# -*- coding: utf-8 -*-
import re
import support as sup
from operator import itemgetter


def align_traces(log, align_info_file, align_type_file):
    """this method is the kernel of all the alignment process"""
    optimal_alignments = read_alignment_info(align_info_file)
    traces_alignments = traces_alignment_type(align_type_file)
    raw_traces=log.get_raw_traces()
    aligned_traces = list()
    i = 0
    size = len(raw_traces)
    for raw_trace in raw_traces:
        try:
            # Alignment of each trace
            aligned_trace = process_trace(raw_trace, optimal_alignments, traces_alignments )
            # Conformity check and error correction
            aligned_trace = trace_verification(aligned_trace, raw_trace)
            # [print(x['task'] + ' ' + str((x['end_timestamp'] - x['start_timestamp']).total_seconds())) for x in aligned_trace]
            aligned_traces.extend(aligned_trace)
        except Exception as e:
            print(str(e))
            # print(raw_trace[0]['caseid'])
        sup.print_progress(((i / (size-1))* 100),'Aligning log traces with model ')
        i += 1
    # Set the aligned data in the log object
    log.set_data(aligned_traces)
    sup.print_done_task()

def process_trace(raw_trace, optimal_alignments, traces_alignments ):
    """this method performs the alignment of each trace according with the data optimal alignment"""
    caseid = raw_trace[0]['caseid']
    alignment_data = list(filter(lambda x: x['caseid'] == caseid, traces_alignments))[0]
    aligned_trace = list()
    # If fitness is 1 all the trace es aligned
    if alignment_data['fitness'] < 1 and alignment_data['fitness'] > 0:
        optimal_alignment = list(filter(lambda x: alignment_data['trace_type'] == x['trace_type'], optimal_alignments))[0]['optimal_alignment']
        j = 0
        for i in range(0,len(optimal_alignment)):
            movement_type = optimal_alignment[i]['movement_type']
            # If the Model and the log are aligned copy the raw value
            if movement_type =='LMGOOD':
                aligned_trace.append(raw_trace[j])
                j += 1
            # If the Log needs an extra task, create the start and complet event with time 0 and user AUTO
            elif movement_type =='MREAL':
                if i == 0:
                    time = raw_trace[i]['start_timestamp']
                else:
                    time = aligned_trace[-1]['start_timestamp']
                aligned_trace.append(dict(caseid=caseid, task=optimal_alignment[i]['task_name'], event_type='start', user='AUTO', start_timestamp=time, end_timestamp=time))
                aligned_trace.append(dict(caseid=caseid, task=optimal_alignment[i]['task_name'], event_type='complete', user='AUTO', start_timestamp=time, end_timestamp=time))
            # If the event appears in the Log but not in the model delete the event from the trace
            elif movement_type =='L':
                j += 1
    elif alignment_data['fitness'] == 1:
        aligned_trace=raw_trace
    return aligned_trace

def trace_verification(aligned_trace, raw_trace):
    """this method performs the conformity check, error correction and joints the start and complete events"""
    data = list()
    i = 0
    while(i < len(aligned_trace)):
        current_event = aligned_trace[i]
        next_event = aligned_trace[i + 1]
        if not (current_event['task'] == next_event['task'] and current_event['event_type'] == 'start' and next_event['event_type'] == 'complete'):
            if current_event['event_type'] == 'start':
                raw_list = sorted(list(filter(lambda x: x['task']==current_event['task'] and x['event_type'] == 'complete' and current_event['start_timestamp'] <= x['start_timestamp'], raw_trace)), key=itemgetter('start_timestamp'))
                aligned_trace.insert(i + 1, raw_list[0])
            elif current_event['event_type'] == 'complete':
                raw_list = sorted(list(filter(lambda x: x['task']==current_event['task'] and x['event_type'] == 'start' and current_event['start_timestamp'] >= x['start_timestamp'], raw_trace)), key=itemgetter('start_timestamp'))
                aligned_trace.insert(i, raw_list[0])
            i = 0
            break
        else:
            i += 2
    # Joining of start and complete events
    if(len(aligned_trace)%2 == 0):
        for i in range(0,len(aligned_trace),2):
            current_event = aligned_trace[i]
            next_event = aligned_trace[i + 1]
            data.append(dict(caseid=current_event['caseid'], task=current_event['task'], event_type=current_event['task'],
                     user=current_event['user'], start_timestamp=current_event['start_timestamp'], end_timestamp=next_event['start_timestamp']))
    return data

# --support --
# Methods for the reading of the alignment data generated by the proconformance plug-in
def read_alignment_info(filename):
    records = list()
    with open(filename) as fp:
        [next(fp) for i in range(3)]
        for line in fp:
            temp_record = line.split(',')
            trace_type = int(temp_record[0])
            optimal_alignment = list()
            for task in temp_record[2:]:
                prog = re.compile('(\w+)(\()(.*)(\))')
                result = prog.match(task)
                if result.group(1) != 'MINVI':
                    optimal_alignment.append(dict(movement_type=result.group(1), task_name=result.group(3).strip()))
            records.append(dict(trace_type=trace_type,optimal_alignment=optimal_alignment))
    return records

def traces_alignment_type(filename):
    records = list()
    with open(filename) as fp:
        [next(fp) for i in range(7)]
        for line in fp:
            temp_record = line.split(',')
            records.append(dict(caseid=temp_record[2],trace_type=int(temp_record[1]),fitness=float(temp_record[11])))
    return records
